{"version":3,"file":"getRoutes.js","sourceRoot":"","sources":["../src/getRoutes.ts"],"names":[],"mappings":"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","sourcesContent":["import { DynamicConvention, RouteNode } from './Route';\nimport {\n  matchArrayGroupName,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  removeSupportedExtensions,\n} from './matchers';\nimport { RequireContext } from './types';\n\nexport type Options = {\n  ignore?: RegExp[];\n  preserveApiRoutes?: boolean;\n  ignoreRequireErrors?: boolean;\n  ignoreEntryPoints?: boolean;\n  /* Used to simplify testing for toEqual() comparison */\n  internal_stripLoadRoute?: boolean;\n  /* Used to simplify by skipping the generated routes */\n  internal_skipGenerated?: boolean;\n};\n\ntype DirectoryNode = {\n  layout?: RouteNode[];\n  files: Map<string, RouteNode[]>;\n  subdirectories: Map<string, DirectoryNode>;\n};\n\n/**\n * Given a Metro context module, return an array of nested routes.\n *\n * This is a two step process:\n *  1. Convert the RequireContext keys (file paths) into a directory tree.\n *      - This should extrapolate array syntax into multiple routes\n *      - Routes are given a specificity score\n *  2. Flatten the directory tree into routes\n *      - Routes in directories without _layout files are hoisted to the nearest _layout\n *      - The name of the route is relative to the nearest _layout\n *      - If multiple routes have the same name, the most specific route is used\n */\nexport function getRoutes(contextModule: RequireContext, options: Options = {}): RouteNode | null {\n  const directoryTree = getDirectoryTree(contextModule, options);\n\n  // If there are no routes\n  if (!directoryTree) {\n    return null;\n  }\n\n  return flattenDirectoryTreeToRoutes(directoryTree, options);\n}\n\n/**\n * Converts the RequireContext keys (file paths) into a directory tree.\n */\nfunction getDirectoryTree(contextModule: RequireContext, options: Options) {\n  const ignoreList: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/]; // Ignore the top level ./+html file\n\n  if (options.ignore) {\n    ignoreList.push(...options.ignore);\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api\\.[tj]sx?$/);\n  }\n\n  const rootDirectory: DirectoryNode = {\n    files: new Map(),\n    subdirectories: new Map(),\n  };\n\n  let hasRoutes = false;\n  let hasLayout = false;\n\n  for (const filePath of contextModule.keys()) {\n    if (ignoreList.some((regex) => regex.test(filePath))) {\n      continue;\n    }\n\n    const meta = getFileMeta(filePath);\n\n    // This is a file that should be ignored. e.g maybe it has an invalid platform?\n    if (meta.specificity < 0) {\n      continue;\n    }\n\n    const node: RouteNode = {\n      type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n      loadRoute() {\n        if (options.ignoreRequireErrors) {\n          try {\n            return contextModule(filePath);\n          } catch {\n            return {};\n          }\n        } else {\n          return contextModule(filePath);\n        }\n      },\n      contextKey: filePath,\n      entryPoints: [filePath], // Additional entry points are added during hoisting\n      route: '', // This is overwritten during hoisting based upon the _layout\n      dynamic: getDynamicConvention(meta.route),\n      children: [], // While we are building the directory tree, we don't know the node's children just yet. This is added during hoisting\n    };\n\n    /**\n     * A single filepath may be extrapolated into multiple routes if it contains array syntax.\n     * Another way to thinking about is that a filepath node is present in multiple leaves of the directory tree.\n     */\n    for (const route of extrapolateGroups(meta.route)) {\n      // Traverse the directory tree to its leaf node, creating any missing directories along the way\n      const subdirectoryParts = route.split('/').slice(0, -1);\n\n      // Start at the root directory and traverse the path to the leaf directory\n      let directory = rootDirectory;\n\n      for (const part of subdirectoryParts) {\n        let subDirectory = directory.subdirectories.get(part);\n\n        // Create any missing subdirectories\n        if (!subDirectory) {\n          subDirectory = {\n            files: new Map(),\n            subdirectories: new Map(),\n          };\n          directory.subdirectories.set(part, subDirectory);\n        }\n\n        directory = subDirectory;\n      }\n\n      // Clone the node for this route\n      const routeNode: RouteNode = { ...node, route };\n\n      if (meta.isLayout) {\n        directory.layout ??= [];\n        const existing = directory.layout[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          directory.layout[meta.specificity] = {\n            ...routeNode,\n            route: routeNode.route.replace(/\\/?_layout$/, ''),\n          };\n          hasLayout ||= true;\n        }\n      } else if (meta.isApi) {\n        const fileKey = `${route}+api`;\n        let nodes = directory.files.get(fileKey);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(fileKey, nodes);\n        }\n\n        // TODO(Platform Route): Throw error if specificity > 0, as you cannot specify platform extensions for api routes\n\n        const existing = nodes[0];\n\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          nodes[0] = routeNode;\n        }\n      } else {\n        let nodes = directory.files.get(route);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(route, nodes);\n        }\n\n        /**\n         * If there is an existing node with the same specificity, then we have a conflict.\n         * NOTE(Platform Routes):\n         *    We cannot check for specificity conflicts here, as we haven't processed all the context keys yet!\n         *    This will be checked during hoisting, as well as enforcing that all routes have a non-platform route.\n         */\n        const existing = nodes[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          nodes[meta.specificity] = routeNode;\n          hasRoutes ||= true;\n        }\n      }\n    }\n  }\n\n  // If there are no routes/layouts then we should display the tutorial.\n  if (!hasLayout && !hasRoutes) {\n    return null;\n  }\n\n  // If there are no top-level _layout, add a default _layout\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [\n      {\n        type: 'layout',\n        loadRoute: () => ({\n          default: (require('./views/Navigator') as typeof import('./views/Navigator'))\n            .DefaultNavigator,\n        }),\n        // Generate a fake file name for the directory\n        contextKey: './_layout.tsx',\n        entryPoints: ['expo-router/build/views/Navigator.js'],\n        route: '',\n        generated: true,\n        dynamic: null,\n        children: [],\n      },\n    ];\n  }\n\n  // Only include the sitemap if there are routes.\n  if (hasRoutes && !options.internal_skipGenerated) {\n    appendSitemapRoute(rootDirectory);\n  }\n\n  if (!options.internal_skipGenerated) {\n    appendNotFoundRoute(rootDirectory);\n  }\n  return rootDirectory;\n}\n\n/**\n * Flatten the directory tree into routes, hoisting routes to the nearest _layout.\n */\nfunction flattenDirectoryTreeToRoutes(\n  directory: DirectoryNode,\n  options: Options,\n  /* The nearest _layout file in the directory tree */\n  nearestLayout?: RouteNode,\n  /* Routes need to contain the entryPoints of their parent layouts */\n  entryPoints: string[] = [],\n  /* Route names are relative to their layout */\n  pathToRemove = ''\n) {\n  /**\n   * All routes get \"hoisted\" to the nearest layout.\n   */\n  if (directory.layout) {\n    // TODO(Platform Routes): We need to pick the most specific layout.\n    const layout = directory.layout[0];\n\n    const previousNearestLayout = nearestLayout;\n    nearestLayout = { ...layout, children: [] };\n\n    // Add the new layout as a child of its parent\n    if (previousNearestLayout) {\n      previousNearestLayout.children.push(nearestLayout);\n    }\n\n    if (options.internal_stripLoadRoute) {\n      delete (nearestLayout as any).loadRoute;\n    }\n\n    // `route` is the absolute pathname. We need to make this relative to the parent layout\n    const newRoute = nearestLayout.route.replace(pathToRemove, '');\n    pathToRemove = nearestLayout.route ? `${nearestLayout.route}/` : '';\n    nearestLayout.route = newRoute;\n\n    if (nearestLayout.entryPoints) {\n      // Track this _layout's entryPoints so that child routes can inherit them\n      entryPoints = [...entryPoints, ...nearestLayout.entryPoints];\n\n      // Layouts never have entryPoints\n      delete nearestLayout.entryPoints;\n    }\n  }\n\n  // This should never occur, but it makes the type system happy\n  if (!nearestLayout) throw new Error('Expo Router Internal Error: No nearest layout');\n\n  for (const routes of directory.files.values()) {\n    // TODO(Platform Routes): We need to pick the most specific layout and ensure that all routes have a non-platform route.\n    let routeNode = routes[0];\n\n    // `route` is the absolute pathname. We need to make this relative to the nearest layout\n    const route = routeNode.route.replace(pathToRemove, '');\n\n    // Merge the entryPoints of the parent layout(s) with the child route\n    let childEntryPoints: string[] | undefined = undefined;\n\n    if (!options.ignoreEntryPoints) {\n      if (routeNode.type === 'api') {\n        childEntryPoints = routeNode.entryPoints;\n      } else if (routeNode.entryPoints) {\n        childEntryPoints = [...entryPoints, ...routeNode.entryPoints];\n      } else {\n        childEntryPoints = [...entryPoints];\n      }\n    }\n\n    routeNode = {\n      ...routeNode,\n      route,\n      entryPoints: childEntryPoints,\n    };\n\n    if (options.internal_stripLoadRoute) {\n      delete (routeNode as any).loadRoute;\n    }\n\n    nearestLayout.children.push(routeNode);\n  }\n\n  // Recursively flatten the subdirectories\n  for (const child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, nearestLayout, entryPoints, pathToRemove);\n  }\n\n  return nearestLayout;\n}\n\nfunction getFileMeta(key: string) {\n  // Remove the leading `./`\n  key = key.replace(/^\\.\\//, '');\n\n  const parts = key.split('/');\n  const filename = parts[parts.length - 1];\n  const filenameWithoutExtensions = removeSupportedExtensions(filename);\n  const isLayout = filenameWithoutExtensions === '_layout';\n  const isApi = filename.match(/\\+api\\.[jt]sx?$/);\n\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ./${key}. Routes cannot end with '(group)' syntax`);\n  }\n\n  // Nested routes cannot start with the '+' character, except for the '+not-found' route\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');\n    throw new Error(\n      `Invalid route ./${key}. Route nodes cannot start with the '+' character. \"Please rename to ${renamedRoute}\"`\n    );\n  }\n\n  return {\n    route: removeSupportedExtensions(key),\n    specificity: 0,\n    isLayout,\n    isApi,\n  };\n}\n\nexport function getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  if (options?.preserveApiRoutes !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\n\n/**\n * Generates a set of strings which have the router array syntax extrapolated.\n *\n * /(a,b)/(c,d)/e.tsx => new Set(['a/c/e.tsx', 'a/d/e.tsx', 'b/c/e.tsx', 'b/d/e.tsx'])\n */\nfunction extrapolateGroups(key: string, keys: Set<string> = new Set()): Set<string> {\n  const match = matchArrayGroupName(key)?.[0];\n\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  const groups = match.split(',');\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n\n  for (const group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n\n  return keys;\n}\n\nfunction getDynamicConvention(path: string): DynamicConvention[] | null {\n  const dynamic = path\n    .split('/')\n    .map((part): DynamicConvention | null => {\n      if (part === '+not-found') {\n        return {\n          name: '+not-found',\n          deep: true,\n          notFound: true,\n        };\n      }\n\n      const deepDynamicName = matchDeepDynamicRouteName(part);\n      const dynamicName = deepDynamicName ?? matchDynamicName(part);\n\n      if (!dynamicName) return null;\n      return { name: dynamicName, deep: !!deepDynamicName };\n    })\n    .filter((part): part is DynamicConvention => !!part);\n\n  if (dynamic?.length === 0) {\n    return null;\n  }\n\n  return dynamic;\n}\n\nfunction appendSitemapRoute(directory: DirectoryNode) {\n  if (!directory.files.has('_sitemap')) {\n    directory.files.set('_sitemap', [\n      {\n        loadRoute() {\n          const { Sitemap, getNavOptions } = require('./views/Sitemap');\n          return { default: Sitemap, getNavOptions };\n        },\n        route: '_sitemap',\n        type: 'route',\n        contextKey: './_sitemap.tsx',\n        generated: true,\n        internal: true,\n        dynamic: null,\n        children: [],\n        entryPoints: ['expo-router/build/views/Sitemap.js'],\n      },\n    ]);\n  }\n}\n\nfunction appendNotFoundRoute(directory: DirectoryNode) {\n  if (!directory.files.has('+not-found')) {\n    directory.files.set('+not-found', [\n      {\n        loadRoute() {\n          return { default: require('./views/Unmatched').Unmatched };\n        },\n        type: 'route',\n        route: '+not-found',\n        contextKey: './+not-found.tsx',\n        generated: true,\n        internal: true,\n        dynamic: [{ name: '+not-found', deep: true, notFound: true }],\n        children: [],\n        entryPoints: ['expo-router/build/views/Unmatched.js'],\n      },\n    ]);\n  }\n}\n"]}